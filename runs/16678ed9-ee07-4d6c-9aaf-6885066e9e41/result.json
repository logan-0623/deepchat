{"status": "success", "type": "pdf", "task_id": "16678ed9-ee07-4d6c-9aaf-6885066e9e41", "file_name": "16678ed9-ee07-4d6c-9aaf-6885066e9e41_626f6beb925ccb471d26763872bc704e.pdf", "content": "\n--- 第 1 页 ---\nSilberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nResource Management \nDeadlocks\n\n--- 第 2 页 ---\n7.2 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nDeadlocks\nSystem Model\nDeadlock Characterization\nMethods for Handling Deadlocks\nDeadlock Prevention\nDeadlock Avoidance\nDeadlock Detection \nRecovery from Deadlock \n--- 第 3 页 ---\n7.3 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nDEADLOCK\n--- 第 4 页 ---\n7.4 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nDeadlock Characterization\nDeadlock can arise if four conditions hold simultaneously.\n❑MUTUAL  EXCLUSION :  only one process  at a time can use a resource\n❑HOLD AND WAIT:  a process  holding  at least  one resource  is waiting  to \nacquire  additional  resources  held by other  processes\n❑NO PREEMPTION :  a resource  can be released  only voluntarily  by the \nprocess  holding  it, after that process  has completed  its task.\nThe first three  conditions  are necessary  but not sufficient  for a deadlock  to exist. For \ndeadlock  to actually  take place,  a fourth  condition  is required :\n❑CIRCULAR  WAIT:  a closed  chain  of processes  exists,  such  that each  \nprocess  holds  at least  one resource  needed  by the next process  in the \nchain  .Deadlock can be defined as the permanent blocking of a set of processes \nthat compete for system resources. \n--- 第 5 页 ---\n7.5 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nSystem Model\nSystem consists of resources\nResource types R1, R2, . . ., Rm\nCPU cycles, memory space, I/O devices\nEach resource type Ri has Wi instances.\nEach process utilizes a resource as follows:\nrequest \nuse \nrelease\n--- 第 6 页 ---\n7.6 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nResource -Allocation Graph\nV is partitioned into two types:\nP = {P1, P2, …, Pn}, the set consisting of all the processes  in the \nsystem\nR = {R1, R2, …, Rm}, the set consisting of all resource  types in the \nsystem\nrequest edge  – directed edge Pi → Rj\nassignment edge  – directed edge Rj → PiA set of vertices V and a set of edges E.\n--- 第 7 页 ---\n7.7 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nResource -Allocation Graph (Cont.)\nProcess\nResource Type with 4 instances\nPi requests  instance of Rj\nPi is holding  an instance of RjPiPi\nRj\nRj\n\n--- 第 8 页 ---\n7.8 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nResource Allocation \nGraph With a DeadlockGraph With a Cycle \nBut No Deadlock\n--- 第 9 页 ---\n7.9 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nBasic Facts\nIf graph contains no cycles  no deadlock\nIf graph contains a cycle \n➢if only one instance  per resource  type,  then deadlock\n➢if several  instances  per resource  type,  possibility  of \ndeadlock\n--- 第 10 页 ---\n7.10 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nHANDLING DEADLOCKS\n--- 第 11 页 ---\n7.11 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nMethods for Handling Deadlocks\nEnsure  that the system  will never  enter  a deadlock  state .\nTo deal with the deadlock,  the following  three  approaches  \ncan be used :\n➢Deadlock  prevention\n➢Deadlock  avoidance\n➢Deadlock  detection  and recovery\nIgnore  the problem  and pretend  that deadlocks  never  occur  in the system  \n(used  by most  operating  systems,  including  UNIX)\n--- 第 12 页 ---\n7.12 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nDeadlock Prevention\n- adopting  a policy  that eliminates  one of the conditions  \n(conditions  1 through  4)\n--- 第 13 页 ---\n7.13 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nDeadlock Prevention\nMutual  Exclusion  – In general,  the first of the four conditions  \ncannot  be disallowed . If access  to a resource  requires  mutual  \nexclusion,  then mutual  exclusion  must  be supported  by the OS. \nHold  and Wait  – must  guarantee  that whenever  a process  \nrequests  a resource,  it does  not hold any other  resources\nRequire  process  to request  and be allocated  all its resources  before  it \nbegins  execution  or allow  process  to request  resources  only when  the \nprocess  has none  allocated  to it.\nLow resource  utilization ; starvation  possible\n--- 第 14 页 ---\n7.14 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nDeadlock Prevention (Cont.)\nNo Preemption  – can be prevented  in several  ways . \n- if a process  holding  certain  resources  is denied  a further  request , that \nprocess  must  release  its original  resources  and, if necessary,  request  them  \nagain  together  with the additional  resource .\n- if a process  requests  a resource  that is currently  held by another  process,  \nthe OS may preempt  the second  process  and require  it to release  its \nresources . \nCircular  Wait  – can be prevented  by defining  a linear  ordering  of \nresource  types . \n- if a process  has been  allocated  resources  of type R, then it may \nsubsequently  request  only those  resources  of types  following  R in the \nordering .\n--- 第 15 页 ---\n7.15 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nDeadlock Avoidance\n- constrain  resource  requests  to prevent  at least  one of the four \nconditions  of deadlock . \n--- 第 16 页 ---\n7.16 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nDeadlock Avoidance\nTwo approaches  to deadlock  avoidance :\n•  Do not start a process  if its demands  might  lead to deadlock .\n• Do not grant  an incremental  resource  request  to a process  if this \nallocation  might  lead to deadlock .\nA safe state  is one in which  there  is at least  one sequence  of resource  \nallocations  to processes  that does  not result  in a deadlock  (i.e., all of the \nprocesses  can be run to completion) . \nAn unsafe  state  is, of course,  a state  that is not safe.\nIf a system is in safe state   no deadlocks\nIf a system is in unsafe state  possibility of deadlock\nAvoidance  ensure that a system will never enter an unsafe state\n--- 第 17 页 ---\n7.17 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nDeadlock Avoidance\nThe avoidance  approach  requires  the knowledge  of:\nMax needs  = total amount  of each  resource  in the system\nAvailable  resources  = total amount  of each  resource  not allocated  \nto any process\nNeed  / Resources  needed=  future  requests  of the process  i for \nresource  j\nAllocation  / Current  allocated  resources  = the resources  allocated  \npresently  to process  i.\nA resource  request  is feasible,  only if the total number  of allocated  resources  of a \nresource  type does  not exceed  the total number  of that resource  type in the \nsystem . \n--- 第 18 页 ---\n7.18 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nSafe state. Example  \nOne resource type, multiple instances: 12 magnetic tape drives \n• If P2 is given  1 more  tape drive,  then no longer  safe -> Av. = 3 -1 = 2\n• What  if P0 now needs  remaining  5 tape drives  to complete ; since  there  \nare only 2 available  (3 – 1), P0 waits\n• What  if P2 also now needs  remaining  6 tape drives  to complete ; since  \nthere  are only 2 available,  P2 waits\n• Even  if P1 completes  and releases  resources,  P0 & P2 deadlocked .At time T0, the system  is in a safe state . The sequence  <P1, P0, P2> \nsatisﬁes  the safety  condition . \nsafe state -> unsafe state. Maximum \nNeedsCurrent needs / \nAllocationNeeds to \ncompleteAvailable \nresources\nP0 10 5 5 3\nP1 4 2 2\nP2 9 2 7\n--- 第 19 页 ---\n7.19 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nDeadlock Avoidance\nTwo approaches to deadlock avoidance:\n❑Single Instance of Resources\n❑Multiple Instances of Resources\n--- 第 20 页 ---\n7.20 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nDeadlock Avoidance in Single Instance of \nResources\nWhere  every  resource  type has a single  instance  \nof resource , the RAG  can be used  \nClaim  edge  Pi → Rj indicated  that process  Pi may \nrequest  resource  Rj; represented  by a dashed  line\nAfter  the cycle  check,  if it is confirmed  that there  \nwill be no circular  wait, the claim  edge  is converted  \nto a request  edge .\nOtherwise,  it will be rejected . \nRequest  edge  converted  to an assignment  edge  \nwhen  the  resource  is allocated  to the process\nWhen  a resource  is released  by a process,  \nassignment  edge  reconverts  to a claim  edge\n\n--- 第 21 页 ---\n7.21 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nDeadlock Avoidance in Multiple Instances of \nResources\nBanker’s Algorithm\nThe banker’s  algorithm  has two parts : \nSafety  Test algorithm  that checks  the current  state  of the \nsystem  for its safe state . \nResource  request  algorithm  that verifies  whether  the \nrequested  resources,  when  allocated  to the process,  affect  \nthe safe state . If it does,  the request  is denied . \n--- 第 22 页 ---\n7.22 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nData Structures for the Banker ’s Algorithm \nLet n = number of processes , and m = number of resources types . \nAvailable :  Vector  of length  m. If Available  [j] = k, there  are k \ninstances  of resource  type Rj  available\nMax: n x m matrix .  If Max [i,j] = k, then process  Pi may request  at \nmost  k instances  of resource  type Rj\nAllocation :  n x m matrix .  If Allocation[ i,j] = k then Pi is currently  \nallocated  k instances  of Rj\nNeed :  n x m matrix . If Need [i,j] = k, then Pi may need  k more  \ninstances  of Rj to complete  its task\nNeed  [i,j] = Max[i,j] – Allocation  [i,j]\n--- 第 23 页 ---\n7.23 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nBanker’s algorithm: Safety Test algorithm \n1. Let Work  and Finish  be vectors of length  m and n, respectively.  \nInitialize :\nWork = Available\nFinish [i] = false for i = 0, 1, …, n- 1\n2. Find an i such that both: \n(a) Finish  [i] = false\n(b) Needi  Work\nIf no such  i exists, go to step 4\n3.  Work  = Work + Allocationi\nFinish [i] = true\ngo to step 2\n4. If Finish  [i] == true for all i, then the system is in a safe state\n--- 第 24 页 ---\n7.24 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nBanker’s algorithm: Resource request algorithm\nRequesti = request  vector  for process  Pi.  \nIf Requesti [j] = k then process  Pi wants  k instances  of resource  type Rj\n1. If Requesti  Needi go to step 2.  Otherwise,  raise  error  condition,  since  \nprocess  has exceeded  its maximum  claim\n2. If Requesti  Available , go to step 3.  Otherwise,  Pi  must  wait, since  \nresources  are not available\n3. Pretend  to allocate  requested  resources  to Pi by modifying  the state  as \nfollows :\n  Available  = Available   – Requesti;\n  Allocationi = Allocationi + Requesti;\n  Needi = Needi – Requesti;\nIf safe  the resources  are allocated  to Pi\nIf unsafe   Pi must  wait, and the old resource -allocation  state  is restored\n--- 第 25 页 ---\n7.25 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nExample of Banker ’s Algorithm\n5 processes P0  through P4; \n     3 resource types :\n              A (10 instances ),  B (5 instances ), and C (7 instances )\nSnapshot at time T0:\n   Allocation    Max Available\n   A B C         A B C A B C\n  P0 0 1 0           7 5 3 3 3 2\n   P1 2 0 0         3 2 2  \n   P2 3 0 2         9 0 2\n   P3 2 1 1         2 2 2\n   P4 0 0 2           4 3 3   \n--- 第 26 页 ---\n7.26 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nExample (Cont.)\nThe content of the matrix Need  is defined to be Max – Allocation\n   Need\n   A B C\n   P0 7 4 3 \n   P1 1 2 2 \n   P2 6 0 0 \n   P3 0 1 1\n   P4 4 3 1 \nThe system is in a safe state since the sequence < P1, P3, P4, P2, P0> \nsatisfies safety criteria\n--- 第 27 页 ---\n7.27 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nExample:  P1 Request (1,0,2)\nCheck that Request  Available (that is, (1,0,2)  (3,3,2)  true\n   Allocation  Need     Available\n   A B C  A B C   A B C \n  P0 0 1 0 7 4 3 2 3 0\n  P1      3 0 2             0 2 0 \n  P2 3 0 2  6 0 0 \n  P3 2 1 1 0 1 1\n  P4 0 0 2  4 3 1 \nExecuting safety algorithm shows that sequence < P1, P3, P4, P0, P2> \nsatisfies safety requirement\nCan request for (3,3,0) by P4 be granted?\nCan request for (0,2,0) by P0 be granted?\n--- 第 28 页 ---\n7.28 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nDeadlock Detection\n--- 第 29 页 ---\n7.29 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nDeadlock Detection\n❑Detection of single instance of resource\n❑Detection for multiple instances of resourcesDeadlock detection has two parts:\n--- 第 30 页 ---\n7.30 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nResource -Allocation Graph and  Wait-for Graph\nResource -Allocation Graph Corresponding  Wait-for Graph\nDetection of single instance of resource\n--- 第 31 页 ---\n7.31 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nDetection of single instance of resource\nMaintain  Wait -for Graph\nNodes  are processes\nPi → Pj   if Pi is waiting for  Pj\nan edge  exists  between  the processes,  only if one \nprocess  waits  for another .\nPeriodically  invoke  an algorithm  that searches  for a \ncycle  in the graph . If there  is a cycle,  there  exists  a \ndeadlock\n--- 第 32 页 ---\n7.32 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nDetection for multiple instances of \nresources\nAvailable :  A vector of length m indicates the number of \navailable resources of each type\nAllocation :  An n x m matrix defines the number of \nresources of each type currently allocated to each process\nRequest :  An n x m matrix indicates the current request  \nof each process.  If Request [i][j] = k, then process  Pi is \nrequesting  k more instances of resource type Rj.\n--- 第 33 页 ---\n7.33 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nDetection Algorithm\n1. Let Work  and Finish  be vectors of length m and n, respectively \nInitialize:\n(a) Work  = Available\n(b) For i = 1,2, …,  n, if Allocationi  0, then \nFinish [i] = false ; otherwise, Finish [i] = true\n2. Find an index i such that both:\n(a) Finish [i] == false\n(b) Requesti  Work\nIf no such i exists, go to step 4The detection algorithm investigates every possible allocation sequence \nfor the processes that remain to be completed . \n--- 第 34 页 ---\n7.34 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nDetection Algorithm (Cont.)\n3. Work  = Work  + Allocationi\nFinish [i] = true\ngo to step 2\n4. If Finish[i] == false , for some i, 1  i   n, then the system is in \ndeadlock state. Moreover, if Finish [i] == false , then Pi is \ndeadlocked\n \n--- 第 35 页 ---\n7.35 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nExample  of Detection Algorithm\n5 processes P0 through P4; \n3 resource types \nA (7 instances), B (2 instances), and C (6 instances)\nSnapshot at time T0:\n    Allocation    Request     Available\n   A B C   A B C A B C\n         P0         0 1 0            0 0 0 0 0 0\n             P1         2 0 0   2 0 2\n             P2         3 0 3            0 0 0 \n             P3         2 1 1   1 0 0 \n         P4             0 0 2    0 0 2\n❑Initial : No deadlock\n❑Sequence < P0, P2, P3, P1, P4> will result in Finish[ i] = true for all i\n--- 第 36 页 ---\n7.36 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nExample (Cont.)\nAssume  P2 requests 1 instance of type  C\n   Request\n   A B C\n   P0 0 0 0\n   P1 2 0 2\n   P2 0 0 1\n   P3 1 0 0 \n   P4 0 0 2\nState of system?\nWe can reclaim  resources  held by process  P0, but insufficient  \nresources  to fulfill other  processes ; requests\nDeadlock exists , consisting of processes P1, P2, P3, and P4\n--- 第 37 页 ---\n7.37 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nDetection -Algorithm Usage\nWhen  should  we invoke  the detection  algorithm?  \nHow often  a deadlock  is likely  to occur?\nHow many  processes  will be affected  by deadlock  when  \nit happens?\nIf detection  algorithm  is invoked  arbitrarily,  there  may be \nmany  cycles  in the resource  graph  and so we would  not be \nable to tell which  of the many  deadlocked  processes  \n“caused” the deadlock .\n--- 第 38 页 ---\n7.38 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nRecovery from Deadlock\n--- 第 39 页 ---\n7.39 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nRecovery from Deadlock\n❑Process Termination / Abort Process\n❑Resource PreemptionTwo options  for breaking a deadlock. \n--- 第 40 页 ---\n7.40 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\n1. Process Termination\nThere are two methods:\n➢Abort all deadlocked processes\n➢Abort one process at a time until the deadlock cycle is \neliminated\nIn which  order  should  we choose  to abort?  Many  factors  may \naffect  which  process  is chosen .\n1.Priority of the process\n2.How long process has computed, and how much longer to \ncompletion\n3.Resources the process has used\n4.Resource's process needs to complete\n5.How many processes will need to be terminated\n--- 第 41 页 ---\n7.41 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\n2. Resource Preemption\nThree issues need to be addressed:\n❑Select  a victim  – a process,  whose  execution  has just started  \nand requires  many  resources  to complete,  will be the right victim  for \npreemption  (minimize  cost).\n❑Rollback  – return  the process  to some  safe state  (safe \ncheckpoint ), restart  it from that state\n❑Starvation  –  it may be possible  that the same  process  is always  \nchosen  for resource  preemption,  resulting  in a starvation  situation . \nThus,  it is important  to ensure  that the process  will not starve . This \ncan be done  by fixing  the number  of times  a process  can be \nchosen  as a victim .\n--- 第 42 页 ---\n7.42 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts – 9th Edition\nSummary\n▪System Model\n▪Deadlock Characterization\n▪Methods for Handling Deadlocks\n▪Deadlock Prevention\n▪Deadlock Avoidance\n▪Deadlock Detection \n▪Recovery from Deadlock \nReading\nTextbook 9th edition, chapter 7 of the module textbookEnd of Lecture"}