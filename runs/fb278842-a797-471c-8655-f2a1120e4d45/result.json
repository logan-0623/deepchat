{"status": "success", "type": "pdf", "task_id": "fb278842-a797-471c-8655-f2a1120e4d45", "file_name": "fb278842-a797-471c-8655-f2a1120e4d45_41eaf059fae05a8a6b57299772053646.pdf", "content": "\n--- 第 1 页 ---\nSilberschatz, Galvin and Gagne © 2013 Operating System Concepts –9thEdition\nProcess Synchronization\nCPT104 -Operating Systems Concepts\n--- 第 2 页 ---\n5.2 Silberschatz, Galvin and Gagne © 2013 Operating System Concepts –9thEdition\nProcess Synchronization\n❑Background\n❑The Critical -Section Problem\n❑Peterson ’s Solution\n❑Synchronization Hardware\n❑Mutex Locks / Mutual exclusion\n❑Semaphores\n❑Classical Problems of Synchronization\n--- 第 3 页 ---\n5.3 Silberschatz, Galvin and Gagne © 2013 Operating System Concepts –9thEdition\nProcess Synchronization\nBackground\nThe Critical -Section Problem\nPeterson ’s Solution\nSynchronization Hardware\nMutex Locks / Mutual exclusion\nSemaphores\nClassical Problems of Synchronization\n--- 第 4 页 ---\n5.4 Silberschatz, Galvin and Gagne © 2013 Operating System Concepts –9thEdition\nWhat is Process Synchronization (PS)?\nPSisthetask ofcoordinating theexecution ofprocesses inaway\nthatnotwoprocesses canhave access tothesame shared data\nandresources, atonetime.\nnprocesses allcompeting tousesome shared resource .\n\n--- 第 5 页 ---\n5.5 Silberschatz, Galvin and Gagne © 2013 Operating System Concepts –9thEdition\nProcess Synchronization \nConcurrent access toshared data may result indata\ninconsistency .\nMaintaining data consistency requires mechanisms to\nensure theorderly execution ofcooperating processes .\nRace condition :The situation where several processes\naccess andmanipulate shared data concurrently .The final\nvalue oftheshared data depends upon which process\nfinishes last.\nToprevent race conditions, concurrent processes must\nbesynchronized\n--- 第 6 页 ---\n5.6 Silberschatz, Galvin and Gagne © 2013 Operating System Concepts –9thEdition\nProcess Synchronization\nBackground\nThe Critical -Section Problem\nPeterson ’s Solution\nSynchronization Hardware\nMutex Locks / Mutual exclusion\nSemaphores\nClassical Problems of Synchronization\n--- 第 7 页 ---\n5.7 Silberschatz, Galvin and Gagne © 2013 Operating System Concepts –9thEdition\nThe Critical Section Problem\nWhen using critical sections, thecode can bebroken down into thefollowing\nsections :\nSome arbitrary code \n(such as initialization).\nSequence of code = CS\n.\nCode that leaves CScode thattries\ntoenter CS\ncan contain any codeEach (concurrent) thread/process hasacode segment, called Critical Section (CS),\ninwhich theshared data isaccessed .Critical Sections aresequences ofcodethat cannot beinterleaved among\nmultiple threads/processes .\n--- 第 8 页 ---\n5.8 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nA. Frank -P. WeisbergRace condition updating a variable\nCS = c odes that reference one variable in a “read-update -write ” fashion\n--- 第 9 页 ---\n5.9 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nCritical section to prevent a race condition\n•Multiprogramming allows logical parallelism (multiple programs toexist in\nmemory atthesame time) uses devices efficiently butwelose correctness\nwhen there isarace condition .\n•Avoid/ forbid /deny execution inparallel inside critical section, even we\nlose some efficiency, butwegain correctness .\n--- 第 10 页 ---\n5.10 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nSolutions to CS problem\nThere are 3requirements that must stand foracorrect\nsolution :\n❑Mutual exclusion\n❑Progress\n❑Bounded waitingConcurrent processes come into conflict when they use the\nsame resource (competitively orshared)\nforexample :I/Odevices, memory, processor time, clock\n--- 第 11 页 ---\n5.11 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nThe Critical -Section Problem\nMutual Exclusion :When aprocess/thread isexecuting initscritical\nsection, noother process/threads can beexecuting intheir critical\nsections .\nProgress :Ifnoprocess/thread isexecuting initscritical section, and\nifthere aresome processes/threads that wish toenter their critical\nsections, then one ofthese processes/threads willgetintothecritical\nsection .Noprocess running outside itscritical region may block any\nprocess .\nBounded Waiting :Noprocess /thread should have towait forever\ntoenter intothecritical section .\n-thewaiting time ofaprocess/thread outside acritical section should\nbelimited (otherwise the process/thread could suffer from\nstarvation ).\n--- 第 12 页 ---\n5.12 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nTypes of solutions to CS problem\n❑Software solutions\n❑algorithms whose correctness relies only ontheassumption\nthatonly oneprocess/thread atatime canaccess amemory\nlocation/resource\n❑Hardware solutions\n❑relyonspecial machine instructions for“locking”\n❑Operating System and Programming Language\nsolutions (e.g.,Java)\n❑provide specific functions and data structures for\nprogrammers touseforsynchronization .\n--- 第 13 页 ---\n5.13 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nSoftware solutions\n--- 第 14 页 ---\n5.14 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nPeterson’s Solution\nisused formutual exclusion that allows twoormore processes to\nshare asingle -use resource without conflict, using only shared\nmemory forcommunication .\nThe central problem is to design the entry and exitsections \ndo {\nentry section\ncritical section -CS\nexit section\nremainder section –RS\n} while(TRUE)\n--- 第 15 页 ---\n5.15 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nPeterson’s Solution\nOnly 2processes, P0andP1\nItwasformulated byGary L.Peterson in1981 .\nProcesses may share some common variables to synchronize their actions.\nintturn; //indicates whose turnitistoenter thecritical section .\nboolean flag[2];//initialized FALSE ,\n//indicates when aprocess wants toenter intotheir CS.\n//flag[i]=trueimplies thatprocess Piisready (i=0,1)\nNEED BOTH theturn andflag[ 2]toguarantee Mutual Exclusion, Bounded\nwaiting ,andProgress .\n--- 第 16 页 ---\n5.16 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nPeterson’s Solution\ndo {\nflag[i] = TRUE;\nturn = j;\nwhile ( flag[j] && turn == j);\nCRITICAL SECTION\nflag[i] = FALSE;\nREMAINDER SECTION\n} \nwhile (TRUE);Peterson’s algorithm\n--- 第 17 页 ---\n5.17 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\ndo {\n// Critical Section\nflag[ 0] = true; // It means P 0 is ready to \nenter its critical section\nturn = 1; // It means that if P 1 wants to \nenter than allow it to enter and P 0 will wait\n// Condition to check if the flag of P 1 is true \nand turn == 1, this will only break when one \nof the conditions gets false.\nwhile (flag[ 1] && turn == 1); // do \nnothing\n/critical section/\n// It  sets the flag of P 0 to false because it \nhas completed its critical section.\nflag[ 0] = false;\n// Remainder Section\n} while (true);Initialization:        flag[0]:=flag[1]:=false \nturn:= 0 or 1\ndo {\n// Critical Section\n// It means process P0 is ready to enter its \ncritical section\nflag[1] = true;\nturn = 0;  // It means that if P0 wants to \nenter than allow it to enter and P1 will wait\n// Condition to check if the flag of P0 is true \nand turn == 0, this will only break when one \nof the conditions gets false.\nwhile (flag[0] && turn == 0); // do nothing\n/critical section/\n//it  sets the flag of P1 to false because it has \ncompleted its critical section.\nflag[1] = false;\n// Remainder Section\n} while (true);Process P0Process P1\n--- 第 18 页 ---\n5.18 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nThis solution is correct:\nThethree CSrequirements aremet:\n❑Mutual Exclusion isassured asonly oneprocess canaccess\nthecritical section atanytime.\neach Pienters itscritical section only ifeither :\nflag[j] =false orturn=i\n❑Progress isalso assured, asaprocess outside thecritical\nsection does notblock other processes from entering thecritical\nsection .\n❑Bounded Waiting ispreserved asevery process gets afair\nchance .\n--- 第 19 页 ---\n5.19 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nHardware Solutions\n--- 第 20 页 ---\n5.20 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\ndo {\nentry section\nCRITICAL SECTION \nexit section\nremainder section \n} while(true)Solution to CS Problem using LOCKS\nControl the entry into CS \nand gets a LOCK on \nrequired resources. \nRemove the LOCK and \nlet the others know that\nits CS is over.\n--- 第 21 页 ---\n5.21 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nHardware Solutions\nSingle -processor environment -could disable interrupts\nEffectively stops scheduling other processes .\nTEST AND SET SOLUTION\n-satisfy the mutual exclusion requirement, but unfortunately donot\nguarantee bounded waiting .Initially :    lock value is set to 0\nLock value = 0 means the critical \nsection is currently vacant and no process \nis present inside it.\nLock value = 1 means the critical \nsection is currently occupied and a process \nis present inside it.\n--- 第 22 页 ---\n5.22 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nHardware Solutions\nMulti -processor environment \n-provides special atomic hardware instructions. Atomic means non-interruptable\n(i.e., the instruction executes as one unit)\n-aglobal variable lock isinitialized to0.\n-theonly Pithatcanenter CSistheonewhich finds lock =0\n-thisPiexcludes allother Pjbysetting lock to1.\nCOMPARE AND SWAP \nSOLUTION\n--- 第 23 页 ---\n5.23 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nHardware Solution\nAdvantages\nApplicable toanynumber ofprocesses oneither asingle processor or\nmultiple processors sharing main memory\nSimple andeasy toverify\nItcan beused tosupport multiple critical sections ;each critical\nsection canbedefined byitsown variable\nDisadvantages\nBusy -waiting iswhen aprocess iswaiting foraccess toacritical\nsection itcontinues toconsume processor time.\nStarvation ispossible when aprocess execute sitscritical section,\nandmore than oneprocess iswaiting foralong time.\nDeadlock isthepermanent blocking ofasetofprocesses waiting an\nevent (the freeing upofCS) that canonly betriggered byanother\nblocked process intheset.\n--- 第 24 页 ---\n5.24 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nOperating Systems and\nProgramming Language Solutions\noMutex \noSemaphore\n--- 第 25 页 ---\n5.25 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\n1. Mutex Lock / Mutual exclusion\n▪Amutex isaprogramming flagused tograb andrelease anobject .\n▪When data processing isstarted that cannot be performed\nsimultaneously elsewhere inthesystem, themutex issettolock which\nblocks other attempts touseit.\n▪The mutex issettounlock when thedata arenolonger needed, orthe\nroutine isfinished .\n‒Toenforce mutex atthekernel level and prevent thecorruption of\nshared data structures -disable interrupts forthesmallest number of\ninstructions isthebest way.\n‒Toenforce mutex inthe software areas –use the busy -wait\nmechanism\nbusy -waiting mechanism isamechanism inwhich aprocess executes\ninaninfinite loop waiting forthevalue ofalock variable toindicate\navailability .\n--- 第 26 页 ---\n5.26 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\n1. Mutex Lock / Mutual exclusion\n▪using mutex istoacquire alock prior toentering acritical\nsection, andtorelease itwhen exiting\n▪Mutex object islocked orunlocked bytheprocess requesting or\nreleasing theresource\n\n--- 第 27 页 ---\n5.27 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\n1. Mutex Locks / Mutual exclusion\nThis type ofmutex lock iscalled aspinlock because theprocess\n“spins” while waiting forthelocktobecome available .\n--- 第 28 页 ---\n5.28 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\n2. Semaphore\n▪Semaphore wasproposed byDijkstra in1965 .\n▪isatechnique tomanage concurrent processes byusing asimple\nnon-negative integer value and shared between threads /\nprocesses .\n▪Only three atomic operations may beperformed onasemaphore :\ninitialize ,decrement ,andincrement .\n➢thedecrement operation may result intheblocking ofaprocess ,and\n➢theincrement operation may result intheunblocking ofaprocess .\nThis variable isused tosolve thecritical section problem and toachieve\nprocess synchronization inthemultiprocessing environment .\n--- 第 29 页 ---\n5.29 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\n2. Semaphore\nAsemaphore Smay beinitialized toanon-negative integer value .\n-isaccessed only through twostandard atomic operations :wait()\nandsignal() .\nwait()operation decrements thesemaphore value\nIftheS<0,then theprocess executing thewait() is\nblocked .Otherwise, theprocess continues execution .\nsignal ()operation increments thesemaphore value .\n\n--- 第 30 页 ---\n5.30 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nUsing semaphores for solving CS \nProblem \nFor nprocesses\nInitialize semaphore Sto 1\nThen only one process is allowed \ninto CS ( mutual exclusion )\nTo allow kprocesses into CS at a \ntime, simply initialize mutex to kProcess Pi:\ndo {\nwait(S);\nCRITICAL SECTION\nsignal(S);\nRS\n} while(true)\n--- 第 31 页 ---\n5.31 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nSemaphore\nThere aretwomain types ofsemaphores :\n❑COUNTING SEMAPHORE –allow anarbitrary resource\ncount .Itsvalue canrange over anunrestricted domain .Itis\nused tocontrol access toaresource that has multiple\ninstances .\n❑BINARY SEMAPHORE –similar tomutex lock.Itcanhave\nonly twovalues :0and1.\nItsvalue isinitialized to1.Itisused toimplement thesolution\nofcritical section problem withmultiple processes .\n--- 第 32 页 ---\n5.32 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nCOUNTING Semaphores \nThe semaphore Sisinitialized tothe number ofavailable\nresources .\nEach process that uses aresource, itperforms aWAIT ()\noperation onthesemaphore (thereby decrementing thenumber\nofavailable resources ).\nWhen aprocess releases aresource ,itperforms aSIGNAL ()\noperation (incrementing thenumber ofavailable resources ).\nWhen thecount forthesemaphore goes to0,allresources\narebeing used .After that, processes thatwish tousearesource\nwillbeblock until thecount becomes greater than 0.\n--- 第 33 页 ---\n5.33 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\n1.Abinary semaphore may beinitialized to1.\n2.TheWAIT() operation (decrementing )checks thesemaphore value .\n▪Ifthevalue is0,then theprocess executing thewait() isblocked .\n▪Ifthevalue is1,then thevalue ischanged to0and theprocess\ncontinues execution .\n3.TheSIGNAL() operation (incrementing )checks tosee ifany\nprocesses areblocked onthissemaphore (semaphore value equals 0).\n▪Ifso,then aprocess blocked byasignal() operation isunblocked .\n▪Ifnoprocesses areblocked ,then thevalue ofthesemaphore isset\nto1.Abinary semaphore may only take onthevalues 0and1.BINARY Semaphores\n--- 第 34 页 ---\n5.34 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nMutex vs. Binary semaphore\nAkey difference between the amutex and abinary\nsemaphore isthat theprocess that locks themutex (sets the\nvalue tozero)must betheonetounlock it(sets thevalue to1).\nIncontrast, itispossible forone process tolock abinary\nsemaphore andforanother tounlock it.(example inthetutorial)\n--- 第 35 页 ---\n5.35 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nSame issues of semaphore\nStarvation -when theprocesses that require aresource\naredelayed foralong time.Process with high priorities\ncontinuously uses theresources preventing low priority\nprocess toacquire theresources .\nDeadlock isacondition where noprocess proceeds for\nexecution, and each waits forresources that have been\nacquired bytheother processes .\n--- 第 36 页 ---\n5.36 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nClassical Problems of Synchronization\n▪The Bounded -Buffer / Producer -Consumer Problem\n▪The Readers –Writers Problem\n▪The Dining -Philosophers Problem\n--- 第 37 页 ---\n5.37 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nClassic Problems of Synchronization\n❑The Bounded -Buffer / Producer -Consumer Problem\nThe mutex binary semaphore provides mutual exclusion foraccesses to\nthebuffer pool andisinitialized tothevalue 1.\nTheempty andfullsemaphores count thenumber ofempty andfullbuffers .\n•thesemaphore empty isinitialized tothevalue n;\n•thesemaphore fullisinitialized tothevalue 0.\n--- 第 38 页 ---\n5.38 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\n❑The Readers –Writers ProblemClassic Problems of Synchronization\nAdata setisshared among anumber ofconcurrent processes .\n•Only onesingle writer canaccess theshared data atthesame time,any\nother writers orreaders must beblocked .\n•Allow multiple readers toread atthesame time,any writers must be\nblocked .\nSolution :Acquiring areader –writer lock requires specifying themode ofthe\nlock:either read orwrite access .\n--- 第 39 页 ---\n5.39 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nClassic Problems of Synchronization\nThe Dining -Philosophers Problem\nHow to allocate several resources among several processes. \nSeveral solutions arepossible :\n•Allow only 4philosophers tobehungry at\natime.\n•Allow pickup only ifboth chopsticks are\navailable .(Done incritical section )\n•Odd #philosopher always picks upleft\nchopstick 1st,\n•Even #philosopher always picks upright\nchopstick 1st.\n--- 第 40 页 ---\n5.40 Silberschatz, Galvin and Gagne ©2013 Operating System Concepts –9thEdition\nSummary\n▪Background\n▪The Critical -Section Problem\n▪Peterson ’s Solution\n▪Synchronization Hardware\n▪Mutex Locks / Mutual exclusion\n▪Semaphores\n▪Classical Problems of Synchronization\nReading\nTextbook 9thedition, chapter 5 of the module textbookEnd of Lecture"}